# UML 类图及 时序图
后续 都会用到 UML的角度来学习

## UML定义
统一建模语言（Unified Modeling Language）。非专利的第三代建模和规约语言

## UML特点
用于 说明、可视化、构建和编写一个正在开发的面向对象的、软件密集系统的制品的 开放方法。
制品：软件开发过程中产生各种各样的图、源代码、测试用例等

## UML2.2分类
+ 结构式图形：强调的是系统式的建模
  + 静态图（类图，对象图，包图） ==》 主要是类图
  + 实现图（组件图，部署图）
  + 剖面图
  + 复合结构图
    
+ 行为式图形：强调系统模型中触发的事件
  + 活动图
  + 状态图
  + 用例图 ==》 在实际工作中用的不少
  
+ 交互式图形：属于 `行为式`图形子集合，强调系统模型中资料流程
  + 通信图
  + 交互概述图（UML2.0）
  + 时序图（UML2.0）
  + 时间图（UML2.0）
  
## UML类图
`Class Diagram`用于表示 类、接口、实例等之间相互的静态关系

虽然名字叫 类图，但 类图中并不只有 类，还有 权限、属性、方法

## 记忆技巧
+ 箭头方向：子类指向父类。子类 --> 父类
  + Eg：∵ 定义子类时，需要通过 `extends`关键字指定父类   
  ∴子类一定知道 父类的定义，但 父类并不知道 子类  
  ∴只有知道 对方信息的时候才能 指向对方

+ 实线--继承 | 虚线--实现
  + 空心三角箭头：继承或实现
  + 实线： is-a关系
  + 虚线： 代表“虚无实体”，需要具体的实现

+ 实现--关联 | 虚线--依赖
  + 虚线-依赖关系：临时用一下，若即若离，虚无缥缈
    + 表示一种使用关系，一个类需要借助另一个类来实现功能，一般使用另一个类作为 `参数`或 `返回值`
  + 实线-关联关系：关系稳定，实打实的关系，铁哥们
    + 表示 一个类对象和 另一个类对象有关联。通常是 一个类有 另一个类对象作为属性
    
+ 空心菱形--聚合 | 实心菱形--组合
  + 菱形就是一个盛东西的器皿（如盘子）
    + 聚合： 代表 `空器皿`里可以放很多 `相同`的东西，聚在一起（箭头方向所指的类）  
    弱关系，整体和局部的关系，两者有着`独立`的生命周期，是 has-a的关系。
      + Eg： <br/>![](http://127.0.0.1:8001/ch1/one/hollow_diamond_polymerization.jpg)
    + 组合： 代表 `满器`里已经有实体结构的存在，生死与共。它们之间是 强关系  
    整体与局部的关系，和 聚合关系相比，关系更强烈，两者有着`相同`的生命周期，是 contain-a的关系
      + Eg：其中在标志 组合关系的时候，常用到 `数字`  
      ![](http://127.0.0.1:8001/ch1/one/solid_diamond_combination.jpg)  
      其中`数字`表达的含义，假设有 A类和 B类，数字标记在 A类侧。注意一定是在`某一时刻`
        + 0..1 ： 0或 1个实例
        + 0..* ： 0或 多个实例
        + 1..1 ： 1个实例
        + 1 ： 只能有一个实例
        + 1..* ：至少有一个实例
      
## UML时序图
`Sequence Diagram`是显示对象之间交互的图，这些 对象是按时间排序的  
建模元素：对象（Actor）、生命线（LifeLine）、控制焦点（Focus of control）、消息（Message)等  
Eg:  
![](http://127.0.0.1:8001/ch1/one/uml_sequence_diagram_eg.jpg)  
可以看到：长方形为 对象（Actor），每个长方形下方有一条虚线，这是 对象的生命线（LifeLine），时间从上到下
流逝。  

在 生命线上的长方形，表示 实例在活动中。如 1：work，表示调用 Client的 work()方法 ，在 1：work实心箭头和
对象Client之间存在一个交集，这个交集就是 控制焦点。2：open 调用Server对象的open方法，经过3返回之后，可以理解
为 Server对象实例的活动暂时结束了。  

整个过程，结合代码：Test类可以看成 客户端，Test类调用 Client类，然后我们看 Client类，里面有 Server类，然后调用
Server类的 open()方法，open()方法执行完了，返回 控制权给 Client类，Server类的 open()活动结束。然后继续看 Server类的
print()方法，而 print()方法又调用了 Device对象的 write()方法。  
注意：实线5在 实线4下方，因为时间的流逝  
然后 write()方法返回，print()方法返回，接着调用 Server类的 close()方法。。。。。。












































